# 01 - 자바 애플리케이션 프로젝트 만들기
- `그레이들`을 이용하여 프로젝트 디렉토리를 구성할 수 있다.
- `그레이들`로 프로젝트를 빌드하고 실행할 수 있다.
- `아파치 메이븐` 프로젝트의 디렉토리 구조를 이해한다.

# 02 - `이클립스 IDE`로 프로젝트 다루기
- `그레이들`을 이용하여 `이클립스 IDE`용 프로젝트로 전환할 수 있다.
- `이클립스` 워크스페이스로 프로젝트를 가져올 수 있다.
- `이클립스`에서 빌드하고 실행할 수 있다.

# 03 - `GitHub.com`에 프로젝트 공유하기
- `.gitignore` 파일의 용도를 이해하고 작성할 수 있다.
- `github.com`의 저장소에 프로젝트를 공유할 수 있다.


# 04 - 리터럴과 콘솔 출력 다루기
- 다양한 유형의 값을 콘솔로 출력할 수 있다.


# 05 - 변수와 키보드 입력 다루기
- 키보드로 입력한 값을 읽을 수 있다.
- 값을 보관하기 위해 변수를 사용할 수 있다.


# 06 - 배열과 흐름 제어문 활용하기
- 배열을 활용하여 여러 개의 데이터를 저장할 수 있다.
- 조건문과 반복문을 활용하여 프로그램의 실행 흐름을 제어할 수 있다.


# 07 - 클래스로 데이터 타입 정의하기
- 클래스를 활용하여 여러 개의 데이터를 한 단위로 묶을 수 있다.
- 클래스와 인스턴스의 관계를 이해한다.
- 인스턴스와 레퍼런스의 관계를 이해한다.
- 레퍼런스 배열을 이해한다.


# 08 - 기본 문법의 활용
- 변수, 상수, 연산자, 조건문, 반복문, 블록, 배열 등의 문법을 활용할 수 있다.


# 09 - 메서드의 존재 이유
- 메서드를 활용하여 코드를 기능 단위로 분리할 수 있다.
- 리팩토링의 개념을 이해한다.
- 리팩토링 기법 중에서 '메서드 추출(Extract Method)'이라는 것을 수행할 수 있다.


# 10 - 클래스로 메서드를 분류하기
- 클래스를 이용하여 관련 메서드를 묶어 관리할 수 있다.
- 리팩토링 기법 중에서 '클래스 추출(Extract Class)'을 수행할 수 있다.


# 11 - 패키지로 클래스를 분류하기
- 패키지를 이용하여 역할에 따라 클래스를 분류할 수 있다.


# 12 - 클래스 필드와 클래스 메서드의 한계
- 클래스 필드와 클래스 메서드의 한계를 이해한다.


# 13 - 인스턴스 필드와 인스턴스 메서드가 필요한 이유
- 인스턴스 필드와 인스턴스 메서드를 사용할 수 있다.
- 스태틱 필드와 인스턴스 필드의 차이점과 용도를 설명할 수 있다.
- 스태틱 메서드와 인스턴스 메서드의 차이점과 용도를 설명할 수 있다.


# 14 - 생성자가 필요한 이유
- 생성자의 용도 이해한다.
- 생성자를 이용하여 인스턴스를 사용하기 전에 필요한 값들을 준비할 수 있다.


# 15 - 인스턴스 연산자와 메서드
- 메서드를 활용하여 인스턴스 값을 다루는 연산자를 정의할 수 있다.
- 캡슐화의 의미를 이해하고, 셋터/겟터를 만들 수 있다.


# 16 - UI 코드와 데이터 처리 코드를 분리하기
- 캡슐화 기법을 이용하여 데이터 처리 코드를 별개의 클래스로 분리할 수 있다.
- 배열 복제를 통해 배열의 크기를 늘릴 수 있다.
- 역할에 따라 클래스를 분리하는 방법과 이점을 이해한다.  


# 17 - 다형성과 형변환 응용
- 다형적 변수를 활용하여 다양한 타입의 데이터를 다룰 수 있다.
- 형변환을 이해하고 다룰 수 있다.


# 18 - 제네릭을 사용하는 방법과 이점
- 제네릭 문법을 이용하여 타입 정보를 파라미터로 주고 받을 수 있다.
- 제네릭 문법으로 특정 타입의 값만 다루도록 제한할 수 있다.


# 19 - CRUD(Create/Retrieve/Update/Delete) 기능 완성
- 데이터를 등록/조회/수정/삭제하는 기능(CRUD)을 구현할 수 있다.


# 20 - 배열 대신 연결 리스트 자료구조 사용하기
- 연결 리스트(linked list) 자료구조를 구현할 수 있다.
- 연결 리스트의 구동 원리를 이해한다.
- 배열 방식과 연결 리스트의 장단점을 안다.
- 중첩 클래스의 활용할 수 있다.


# 21 - 스택 자료구조 구현과 활용
- 스택(stack) 자료구조를 구현할 수 있다.
- 스택의 구동 원리를 이해하고 활용할 수 있다.
- 인스턴스를 복제할 수 있다.


# 22 - 큐 자료구조 구현과 활용
- 큐(queue) 자료구조를 구현할 수 있다.
- 큐의 구동원리를 이해하고 활용할 수 있다.


# 23_1 - 일반화(generalization) 상속 기법을 사용하여 ArrayList와 LinkedList의 공통점 분리하기
- 상속 기법 중 일반화 기법을 수행할 수 있다.
- 클래스의 공통점을 유지보수 하기 쉽게 분리하기 위해 상속을 이용할 수 있다.
- 다형적 변수를 이용하여 다양한 서브 타입 객체를 다룰 수 있다.
- 의존성 주입(DI) 기법을 이용하여 객체를 부품처럼 교체하기 쉽도록 만들 수 있다.


# 23_2 - generalization을 통해 추출한 수퍼 클래스를 추상 클래스로 정의하기
- 추상 클래스를 정의할 수 있다.
- 추상 클래스 문법의 용도를 이해한다.
- 추상 메서드를 정의할 수 있다.
- 추상 메서드 문법의 용도를 이해한다.


# 23_3 - 인터페이스를 활용하여 객체 사용 규칙 정의하기
- 인터페이스의 용도와 이점을 이해한다.
- 객체 간의 사용 규칙을 정의할 때 인터페이스를 활용할 수 있다.


# 24_1 - `Iterator` 디자인 패턴의 활용
- `Iterator` 디자인 패턴의 용도를 이해하고 활용할 수 있다.
- 자료구조와 상관없이 일관된 방법으로 데이터를 조회할 수 있다.


# 24_2 - `Iterator` 구현체와 스태틱 중첩 클래스(static nested class)
- 스태틱 중첩 클래스를 사용할 수 있다.
- 스태틱 중첩 클래스를 사용하여 인터페이스 구현체를 만들 수 있다.


# 24_3 - `Iterator` 구현체와 논스태틱 중첩 클래스(non-static nested class; inner class)
- 논스태틱 중첩 클래스를 사용할 수 있다.
- 스태틱 중첩 클래스와 논스태틱 중첩 클래스 사이의 차이점을 이해한다.
- 논스태틱 중첩 클래스를 사용하여 인터페이스 구현체를 만들 수 있다.


# 24_4 - `Iterator` 구현체와 로컬 클래스(local class)
- 로컬 클래스를 사용할 수 있다.
- 로컬 클래스의 용도를 이해한다.


# 24_5 - `Iterator` 구현체와 익명 클래스(local class)
- 익명 클래스를 사용할 수 있다.
- 익명 클래스의 용도를 이해한다.


# 25 - 자바 컬렉션 API 사용하기
- 자바에서 제공하는 자료구조 구현체를 활용할 수 있다.


# 26 - `커맨드(Command)` 디자인 패턴을 적용하기
- `Command` 디자인 패턴의 개념과 용도를 이해한다.
- `Command` 디자인 패턴을 활용할 수 있다.


# 27 - 예외가 발생했을 때 시스템을 멈추지 않게 하는 방법
- 예외 처리 문법을 사용할 수 있다.
- 예외 처리 문법의 존재 의의 사용법을 한다.


# 28_1 - 파일 입출력 API의 활용
- 애플리케이션을 종료한 후에도 계속 데이터를 유지할 수 있다.
- 파일 입출력 API를 활용하여 데이터를 읽고 쓸 수 있다.
- 파일 입출력 API에 적용된 `Decorator` 디자인 패턴의 특징과 이점을 안다.


# 28_2 - CSV 문자열을 객체로 전환하는 기능을 도메인 객체로 이전 
- 코드를 메서드로 추출할 수 있다.(리팩토링)
- 메서드를 역할에 맞춰 다른 클래스로 이동할 수 있다.(리팩토링)
- 스태틱 메서드의 용도를 이해하고 활용할 수 있다.
- 인스턴스 메서드의 용도를 이해하고 활용할 수 있다.


# 28_3 - 파일 포맷으로 JSON 도입하기 
- 외부 라이브러리를 가져와서 프로젝트에 적용할 수 있다.
- JSON 포맷의 사용 이점을 이해한다.
- Google JSON 라이브러리를 사용할 수 있다.


# 28_4 - 파일 입출력 시에 버퍼 기능 추가하기
- 데코레이터 디자인 패턴을 이해한다.
- 파일 입출력 클래스에 다른 클래스를 붙여 기능을 확장할 수 있다.
- 버퍼 기능을 수행하는 입출력 클래스의 동작원리를 이해한다.


# 29 - 바이너리 형식으로 입출력하는 방법
- 바이너리 입출력 스트림 클래스를 사용하여 객체의 필드 값을 바이너리 형식으로 읽고 쓸 수 있다.
- DataInputStream/DataOutputStream을 사용할 수 있다.


# 30 - 직렬화와 역직렬화를 이용하여 객체를 통째로 읽고 쓰기
- 객체를 직렬화하여 출력하고 역직렬화 하여 읽어 들일 수 있다.
- `java.io.Serializable` 인터페이스와 `serialVersionUID` 스태틱 변수의 용도를 이해한다. 


# 31_1 - `Observer` 디자인 패턴을 적용하여 클래스 구조를 변경
- `Observer` 디자인 패턴의 용도와 이점을 이해한다.
- 옵저버 호출 규칙을 정의할 수 있다.
- 옵저버 구현체를 등록하고 제거하는 메서드를 추가할 수 있다.
- 특정 상태에서 옵저버를 호출할 수 있다.


# 31_2 - 애플리케이션을 시작하거나 종료할 때 데이터를 로딩하고 저장할 옵저버를 추가한다.
- 옵저버 디자인 패턴에 따라 옵저버를 정의할 수 있다.


# 31_3 - 애플리케이션을 시작하거나 종료할 때 안내 문구를 출력하기
- 옵저버 디자인 패턴에 따라 기능을 추가할 수 있다.


